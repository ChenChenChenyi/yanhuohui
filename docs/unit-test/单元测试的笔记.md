# 单元测试的笔记

## 买猪肉的例子

![图片](D:\烟火会\project\yanhuohui-batch\springbatch4.3.4Doc\pics\640.webp)

上面的代码流程中，getPork()获取猪肉方法是service层提供给controller层的直接调用方法；

service.getPork()里面会去调用service中起其他方法，比如查库存，包装和进货；

由此可以确认需要测试的mock点是加灰的步骤。



在已知待单测业务链路的前提下，写法可以简要归纳为以下几步：

1. 初步设计单测用例框架。包括setup、teststep、teardown三步，setup负责处理一些全局必要的单测前置逻辑(例如Mock数据插入和环境准备)，teststep承载单测用例的主体(要求以Assert类近似的断言语句为结尾)，teardown负责处理一些全局必要的收尾逻辑(例如Mock数据删除和环境释放)

2. 声明并初始化用例所涉及的所有链路环节。在已知链路流程的前提下，所有环节都可以依据是否为Mock点方法大致分为两类(参考上文中"用户买猪"图的灰、白点)。

- 非Mock点方法：对于链路中非入口的环节(通常将controller作为入口，其他方法即为非入口)，需要标注@Spy以声明该对象在单测链路中为监听状态，即需要正常走完流程。此处根据方法内是否引用Mock点方法进一步分成两类。

  ​		1）该方法内引用了其他Mock点方法，需要在@Spy的基础上额外标注@InjectMocks，声明该对象在单测链路中需要被注入其他Mock对象。

  ​		2）该方法内未引用其他Mock点方法，无需进行其他操作。

- Mock点方法：标注@Mock以声明该对象在单测链路中需要被Mock，可以通过org.mockito.Mockito类内的一系列static方法手动注入Mock值(ep. when(A()).thenReturn(B))。

3.  编写单测用例主体。在teststep中从controller层发起方法调用，最终通过Assert断言结果判断用例的成功与否。除了普通的返回值校验场景外，Junit也支持用@Test(expected = xxException.class)来声明该用例期望发生的异常类型。最后还是建议写完单测后能够以注释的形式说明该单测所支持的场景和预期结果的大致说明，方便以后自己和其他接手的同学能够快速了解这个单测用例的相关信息



![图片](D:\烟火会\project\yanhuohui-batch\springbatch4.3.4Doc\pics\640-1642398796903.webp)  